// RingTheBell 2025
// Author: https://github.com/Mark-MDO47/
//
// https://github.com/Mark-MDO47/RingTheBell
//

/*
   Copyright 2025 Mark Olson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

#include "Arduino.h"                // general Arduino definitions plus uint8_t etc.


////////////////////////////////////////////////////////////////////////////////////////
//
// This can compile either for either Arduino Nano/Uno or ESP32 (not ESP32-S3; would need to check pin assignments)
// The pin definitions are necessarily different for ESP32 and NANO/UNO compiles.
//    I have not added definitions for ESP32-S3, which is probably different than the ESP32 pins.
//
// If compiled for Nano, OTA (Over-The-Air update) is not available.

#define COMPILE_AS_ESP32 1 // only one of these can be 1; the other must be 0
#define COMPILE_AS_NANO  0 // only one of these can be 1; the other must be 0

////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////
// YX5200 related info
//
// Attributions for the sounds are on the MicroSD card containing the sounds.
// The sounds are either obtained from https://freesound.org/ or else generated by me using Audacity https://www.audacityteam.org/

// See https://github.com/Mark-MDO47/AudioPlayer-YX5200 for details on using the YX5200/DFPlayer.
//   I usually install a copy of the DFRobot.com DFPlayer code when using it, since I did a lot
//   of debugging to find how to use it on all the variants of the YX5200 I have seen.
//   The still unmodified DFRobot.com DFPlayer code files are DFRobotDFPlayerMini.*.
//   LICENSE_for_DFRobot_code.txt shows it is OK to do this and describes the legal boundaries
//   for correct usage.
////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////
// Delay definitions

#define LOOP_DELAY_MSEC       20  // milliseconds; this delay should be less than one-half of MIN_DEBOUNCE_MSEC
#define MIN_DEBOUNCE_MSEC    120  // milliseconds to debounce control inputs
#define SOUND_ACTIVE_PROTECT 200  // milliseconds to keep YX5200 SW twiddled sound active after doing myDFPlayer.play(mySound)

////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
// ESP32 pin definitions:
//    NOTE: these are good pins for most ESP32 - see https://randomnerdtutorials.com/esp32-pinout-reference-gpios/
//    If using an ESP32-S3, see https://randomnerdtutorials.com/esp32-s3-devkitc-pinout-guide/ and make any
//       needed adjustments.
//
// Control inputs for Sound Processing - these two are GPIO pins with internal pull-up capability
//   ESP32 Dev Module pin D-13   DPIN_MALLET_HIT  when it goes LOW
//   ESP32 Dev Module pin D-27   DPIN_RING_BELL   when it goes LOW
// 
// YX5200/DFPlayer Sound Player
//   ESP32 Dev Module pin D-16   DPIN_SRL_RX   Arduino RX; YX5200 TX - 9600 Baud
//   ESP32 Dev Module pin D-17   DPIN_SRL_TX   Arduino TX; YX5200 RX - 9600 Baud
//   ESP32 Dev Module pin D-23   DPIN_AUDIO_BUSY YX5200 BUSY; HIGH when audio finishes
//
// For ESP32 only: this can be updated via LOW-pulse on DPIN_OTA, which will cause us to open a
//      web page on the specified SSID allowing Over-The-Air software update.
//   That capability is based on the ESP32 example OTAWebUpdater.ino, with my tweaks.
//
// Control inputs for OTA update
//   ESP32 Dev Module pin D-22   DPIN_OTA         when it goes LOW
//
////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
// NANO (and UNO) pin definitions:
//
// Control inputs for Sound Processing - these two are GPIO pins with internal pull-up capability
//   NANO (or UNO) pin D-04   DPIN_MALLET_HIT  when it goes LOW
//   NANO (or UNO) pin D-06   DPIN_RING_BELL   when it goes LOW
//
//   NANO (or UNO) pin D-10   DPIN_SRL_RX   Arduino RX; YX5200 TX - 9600 Baud
//   NANO (or UNO) pin D-11   DPIN_SRL_TX   Arduino TX; YX5200 RX - 9600 Baud
//   NANO (or UNO) pin D-12   DPIN_AUDIO_BUSY YX5200 BUSY; HIGH when audio finishes
//
////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
#if COMPILE_AS_ESP32
// mdo_use_ota_webupdater https://github.com/Mark-MDO47/UniRemote/tree/master/code/mdo_use_ota_webupdater
// This does not connect to WiFi router until it gets turned on
#define MDO_USE_OTA  1 // zero to not use, non-zero to use OTA ESP32 Over-The-Air software updates
#define FORCE_OTA_ON_IF 1 // ESP32: non-zero to force OTA to be on always without needing the pin ONLY if MDO_USE_OTA is also on

#if MDO_USE_OTA
#include "../lib_mdo_use_ota/mdo_use_ota_webupdater.h"   // for mdo_use_ota_webupdater "library"
#include "../lib_mdo_use_ota/mdo_use_ota_webupdater.cpp" // for mdo_use_ota_webupdater "library"
#define FORCE_OTA_ON FORCE_OTA_ON_IF // DO NOT EDIT THIS - keep choice above
#else // not MDO_USE_OTA
#define FORCE_OTA_ON 0 // DO NOT EDIT THIS - don't allow mistake
#endif // MDO_USE_OTA

#include "HardwareSerial.h"         // to talk with the YX5200 - ESP32 uses hardware serial port

////////////////////////////////////////////////////////////////////////////////////////
// pins for Control Inputs
// NOTE: If using computer to control these pins, either adjust the LOOP_DELAY_MSEC above
//           or else adjust your control timing per the following:
//       You must hold control signals LOW for at least 2.5 * LOOP_DELAY_MSEC to ensure
//           correct operation. Nyquist says 2 but common sense says add a smidgeon.
//           We could actually catch the edge with a factor of 1.5 but overkill is authorized.
//       A human pressing a button will almost certainly meet this criteria.

#define DPIN_MALLET_HIT 13 // ESP32: goes LOW to start the Mallet Hit and rising sound SOUNDNUM_MalletHit
#define DPIN_RING_BELL  27 // ESP32: goes LOW to start the bell ringing sound SOUNDNUM_RingBell

#if MDO_USE_OTA // if using Over-The-Air software updates
#define DPIN_OTA        22 // ESP32: goes LOW to start the OTA web server
#endif // MDO_USE_OTA // if using Over-The-Air software updates

////////////////////////////////////////////////////////////////////////////////////////
// pins for YX5200/DFPlayer

#define DPIN_SRL_RX   16  // HW-serial in  - talk to DFPlayer audio player (YX5200)
#define DPIN_SRL_TX   17  // HW-serial out - talk to DFPlayer audio player (YX5200)
#define DPIN_AUDIO_BUSY 23  // digital input - HIGH when audio finishes

#endif // COMPILE_AS_ESP32
////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////
#if COMPILE_AS_NANO
#define MDO_USE_OTA 0  // Nano/Uno has no OTA ESP32 Over-The-Air software updates
#define FORCE_OTA_ON 0 // Nano/Uno has no OTA ESP32 Over-The-Air software updates

#include "SoftwareSerial.h"  // to talk to myDFPlayer without using up debug serial port

////////////////////////////////////////////////////////////////////////////////////////
// pins for Control Inputs
// NOTE: If using computer to control these pins, either adjust the LOOP_DELAY_MSEC above
//           or else adjust your control timing per the following:
//       You must hold control signals LOW for at least 2.5 * LOOP_DELAY_MSEC to ensure
//           correct operation. Nyquist says 2 but common sense says add a smidgeon.
//           We could actually catch the edge with a factor of 1.5 but overkill is authorized.
//       A human pressing a button will almost certainly meet this criteria.

#define DPIN_MALLET_HIT 4 // Nano/Uno: goes LOW to start the Mallet Hit and rising sound SOUNDNUM_MalletHit
#define DPIN_RING_BELL  6 // Nano/Uno: goes LOW to start the bell ringing sound SOUNDNUM_RingBell

////////////////////////////////////////////////////////////////////////////////////////
// pins for YX5200/DFPlayer

#define DPIN_SRL_RX     10  // Nano/Uno: SW-serial in  - talk to DFPlayer audio player (YX5200)
#define DPIN_SRL_TX     11  // Nano/Uno: SW-serial out - talk to DFPlayer audio player (YX5200)
#define DPIN_AUDIO_BUSY 12  // Nano/Uno: digital input - HIGH when audio finishes

SoftwareSerial mySoftwareSerial(DPIN_SRL_RX, DPIN_SRL_TX); // to talk to YX5200 audio player

#endif // COMPILE_AS_NANO


////////////////////////////////////////////////////////////////////////////////////////
// definitions for YX5200/DFPlayer

uint32_t gTimerForceSoundActv = 0;  // SOUND_ACTIVE_PROTECT until millis() >= this

#include "SoundNum.h"               // numbers for each sound
#include "../lib_DFPlayerMini/DFRobotDFPlayerMini.h"    // to communicate with the YX5200 audio player
#include "../lib_DFPlayerMini/DFRobotDFPlayerMini.cpp"  // to communicate with the YX5200 audio player
DFRobotDFPlayerMini myDFPlayer;                         // to talk to YX5200 audio player
void DFsetup();                                         // how to initialize myDFPlayer

#define SOUND_VOL_MIN      0   // range 0 to 30
#define SOUND_VOL_MAX      30  // range 0 to 30
#define SOUND_VOL_DEFAULT  25  // default volume - range 0 to 30

// #define DFPRINTDETAIL 1 // if need detailed status from myDFPlayer (YX5200 communications)
#define DFPRINTDETAIL 0  // will not print detailed status from myDFPlayer

#if DFPRINTDETAIL // routine to do detailed debugging
  void DFprintDetail(uint8_t type, int value); // definition of call
#else  // no DFPRINTDETAIL
  #define DFprintDetail(type, value) // nothing at all
#endif // #if DFPRINTDETAIL

#include "../lib_commonDFcode/lib_commonDFcode.cpp" // separated so the essence can be viewed as a piece
//   DFsetup(); - call from setup() routine; does everything except setup pins and serial
//   DFstartSound(uint16_t p_SoundNum, uint16_t p_Volume); - starts new sound even if currently playing a sound
//   DFcheckSoundDone(); - returns TRUE if current sound is complete
//   DFprintDetail(uint8_t type, int value); - optional routine to break out error code onto Serial

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// DFsetup_pins_serial() - connect YX5200 to hardware pins and serial resources
//    Done here so the hardware differences are visible, not hidden in lib_commonDFcode.cpp
//
// NOTE: DPIN_AUDIO_BUSY must be capable of INPUT_PULLUP operation
//
void DFsetup_pins_serial() {
  pinMode(DPIN_AUDIO_BUSY,  INPUT_PULLUP); // HIGH when audio stops

  // ESP32 and NANO versions of code
  //    start serial port at 9600
  //    start communications with myDFPlayer YX5200; see if it is happy
#if COMPILE_AS_ESP32
  Serial2.begin(9600, SERIAL_8N1, DPIN_SRL_RX, DPIN_SRL_TX); // this is ESP32 control to DFPlayer audio player 
  if (!myDFPlayer.begin(Serial2, false, true))  // ESP32 uses Serial2 to communicate with YX5200
#endif // #if COMPILE_AS_ESP32
#if COMPILE_AS_NANO
  // mySoftwareSerial already connected to serial pins during object creation
  mySoftwareSerial.begin(9600); // this is Nano control to DFPlayer audio player
  if (!myDFPlayer.begin(mySoftwareSerial, false, true))
   // Nano uses SoftwareSerial to communicate with mp3 player
#endif // COMPILE_AS_NANO
  // if communications with myDFPlayer are not happy, report it and wait forever
  {
    Serial.println(F("Unable to begin DFPlayer:"));
    Serial.println(F("1.Please recheck the connection!"));
    Serial.println(F("2.Please insert the SD card!"));
    while(true){
      delay(1000); // wait forever; no recovery from this
    }
  }
} // end DFsetup_pins_serial()


#if MDO_USE_OTA // if using Over-The-Air software updates
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// init_ota() - Over-The-Air software update - ESP32 only
//       returns: 0 if no error
//
//   start OTA
//
uint16_t init_ota() {

  // setup() already did START_OTA_WEB_BEGIN_WIFI
  mdo_ota_web_request(START_OTA_WEB_INIT_WIFI_STA | START_OTA_WEB_BEGIN_WIFI | START_OTA_WEB_INIT_MDNS | START_OTA_WEB_INIT_UPDATER_WEBPAGE);
  // after this, mdo_ota_web_loop() will handle it
  Serial.println("");
  Serial.print("WiFi OTA Connected to ");
  Serial.println(g_ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  Serial.printf("\nOTA Web Updater STARTED\n");

  return(0);
} // end init_ota()
#endif // MDO_USE_OTA if using Over-The-Air software updates

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// ControlActive() - returns non-zero if control transitioned to LOW
//                   only returns non-zero again once until has transitioned to HIGH for at least MIN_DEBOUNCE_MSEC milliseconds
//
// p_dpin         - pin number to check for input
// p_idx_plus_one - the "sound" number associated with this pin
//
int ControlActive(int p_dpin, int p_idx_plus_one) {
  static uint32_t msec32_prev[SOUNDNUM_MAX_PLUS]; // initially zero
  static uint64_t msec64_control_countdown[SOUNDNUM_MAX_PLUS]; // initially zero
  static uint64_t msec64_now = 0;

  uint32_t msec32_now = millis();
  int ctl_state = digitalRead(p_dpin);
  int my_idx = p_idx_plus_one - 1;
  int my_ret = 0;


  // convert to 64-bit msec count so we "never" run out, not even after 49.7 days per 32-bit count
  if (msec32_now >= msec32_prev[my_idx]) {
    msec64_now += ((uint64_t) msec32_now) - ((uint64_t) msec32_prev[my_idx]);
  } else {
    // this happens about once every 49.7 days
    msec64_now +=  (0x100000000LL - ((uint64_t) msec32_prev[my_idx])) + ((uint64_t) msec32_now);
  }

  // if control is HIGH, keep track of the countdown. If countdown set to zero, we will flag next LOW
  if ((HIGH == ctl_state) && (msec64_now >= msec64_control_countdown[my_idx])) {
    // this is at least MIN_DEBOUNCE_MSEC after the last time we saw it LOW
    msec64_control_countdown[my_idx] = 0; // 
  }

  // if control is LOW and countdown is zero, we will return a 1 on this call
  if ((0 == msec64_control_countdown[my_idx]) && (LOW == ctl_state)) {
    // only return NON-ZERO if not waiting for debounce and LOW
    my_ret = 1; // first LOW since debounce; return TRUE
  }

  // if control is LOW, we alway update (extend) the countdown
  if  (LOW == ctl_state) {
    // always update the countdown if control state is LOW
    msec64_control_countdown[my_idx] =  msec64_now + ((uint64_t) MIN_DEBOUNCE_MSEC);
  }

  return(my_ret);
} // end ControlActive()

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// setup()
void setup() {
  Serial.begin(115200);         // this serial communication is for general debug; set the USB serial port to 115,200 baud
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  delay(1000);
  Serial.println(""); // print a blank line in case there is some junk from power-on
  Serial.println("starting RingTheBell");

  // initialize the control pins; active LOW
  pinMode(DPIN_MALLET_HIT, INPUT_PULLUP);
  pinMode(DPIN_RING_BELL, INPUT_PULLUP);
#if MDO_USE_OTA // if using Over-The-Air software updates
  pinMode(DPIN_OTA, INPUT_PULLUP);
#endif // MDO_USE_OTA // if using Over-The-Air software updates

  // initialize the YX5200 DFPlayer audio player
  Serial.println("\nInitialize YX5200");
  DFsetup_pins_serial(); // this routine is inside this *.ino; has ESP32 and NANO specific code
  DFsetup(); // this routine is in lib_commonDFcode.cpp; sets up YX5200 for our method of operation
  // start the first sound, then allow normal loop() processing
  DFstartSound(SOUNDNUM_silence, SOUND_VOL_DEFAULT);
  Serial.println("  DFstartSound silence");

  Serial.println("\nRingTheBell init complete...");

} // end setup()

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// loop()
//
void loop() {
  static uint16_t print_silence = 2;

  if (ControlActive(DPIN_MALLET_HIT, SOUNDNUM_MalletHit)) {
    DFstartSound(SOUNDNUM_MalletHit, SOUND_VOL_DEFAULT); // force sequence start
    Serial.println("  DFstartSound MalletHit");
    print_silence = 2;
  } else if (ControlActive(DPIN_RING_BELL, SOUNDNUM_RingBell)) {
    DFstartSound(SOUNDNUM_RingBell, SOUND_VOL_DEFAULT); // force sequence finish - expected prior to sound done
    Serial.println("  DFstartSound RingBell");
    print_silence = 2;
  } else if (DFcheckSoundDone()) {
    // next sound in sequence - silence
    if (0 != print_silence) {
      DFstartSound(SOUNDNUM_silence, SOUND_VOL_DEFAULT); // sequence to silence
      Serial.printf("  DFstartSound silence %d\n", print_silence);
      print_silence -= 1;
    }
  }

#if MDO_USE_OTA // if using Over-The-Air software updates
  static uint16_t ota_needs_init = 1;
  if ((ControlActive(DPIN_OTA, SOUNDNUM_save_for_OTA) || (FORCE_OTA_ON))  &&  ota_needs_init) {
    ota_needs_init = 0; // only do the init once
    init_ota();
  }

  // respond to OTA web server if there is user action
  if (0 == ota_needs_init) {
    mdo_ota_web_loop();
  }
#endif // MDO_USE_OTA if using Over-The-Air software updates

  // this delay should be less than one-half of MIN_DEBOUNCE_MSEC
  delay(LOOP_DELAY_MSEC);
} // end loop()
